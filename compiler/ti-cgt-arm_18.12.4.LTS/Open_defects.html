
<!-- saved from url=(0099)http://gtjenkins.itg.ti.com:8080/job/JIRA-SDOWP-Generate-Report/543/artifact/jira-query-report.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style>
    table {border-collapse:collapse; table-layout:fixed; width:310px;}
    table td {border: none solid black; width:100px; word-wrap:break-word;}
    th {  background: #eee; }
    </style>
    </head>
    <body>
    <table style="text-align:left; width: 100%; border:1px solid #CCC;border:none;">
    <tbody><tr>
    
    <td align="left">
    <a href="http://www.ti.com/">
    <img alt="" src="data:image/gif;base64,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">
    </a>
    </td>
    </tr>
    <tr><td align="center"><h1>Open Defects in Release</h1></td></tr>
    </tbody></table>
    <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
    <thead>
    <tr>
    <th align="center">ID</th>
    <th align="center">Summary</th>
    <th align="center">State</th>
    <th align="center">Reported In Release</th>
    <th align="center">Target Release</th>
    <th align="center">Workaround</th>
    <th align="center">Release Notes</th>
    </tr>
    </thead><tbody><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-6710?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-6710</a></td>
        <td>Assembler fails with INTERNAL ERROR!: failed to locate symbol for relocation entry at offset</td>
        <td>Open</td>
        <td>ARM_18.12.3.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-6070?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-6070</a></td>
        <td>Erroneous "redeclared with incompatible type" involving two tagless structs with same form</td>
        <td>Planned</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>For this specific case, which involved the BLE stack:

Edit file blestack/inc/att.h

Find the typedef for attReadByTypeReq_t.  Give the struct a tag (name).  Any name will do as long as it is unique.  Do the same for attReadByGrpTypeReq_t.

Recompile all C files.

-or-

make sure all files are compiled as C or all files are compiled as C++.</td>
        <td>User-defined types defined in separate translation units are technically different types in C, but the C compiler merges them when it can determine that they are the same type, such as when there is a declaration in each translation unit for a symbol with external linkage.  This bug was caused by type merging being a bit too aggressive in merging two structs that had exactly the same form, with identical members, but distinct struct tags.  Type merging mistakenly thought it could merge these because it saw a function prototype that involved not exactly the same type, but a compatible type without a tag, and this function was later defined using both fully-defined types, this time with the struct tags.  This particular bug cannot happen as long as you always use a tag (name) when declaring a struct or union.  This is the name that appears after the keyword "struct" or "union" but before the opening curly brace.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5179?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5179</a></td>
        <td>When a symbol is remapped, the associated Dwarf debug info is not updated</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5146?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5146</a></td>
        <td>Testing the recent thread-safety changes to __vla_alloc and __vla_dealloc</td>
        <td>Planned</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-5078?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-5078</a></td>
        <td>Simple syntax error causes assembler to fail with INTERNAL ERROR</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4985?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4985</a></td>
        <td>Typo on ULP Advisor message</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>N/A.</td>
        <td>In certain ULP Advisor messages, the word "variables" is mistyped as "varaibles". 



An example is shown below:



#2623-D (ULP 5.4) Detected an assignment to a type with size less than int. To avoid unnecessary sign extension, use int-sized types for local varaibles and convert to smaller types for static storage. system_msp432p401r.c /WarningTest_MSP432 line 156

#2623-D (ULP 5.4) Detected an assignment to a type with size less than int. To avoid unnecessary sign extension, use int-sized types for local varaibles and convert to smaller types for static storage. system_msp432p401r.c /WarningTest_MSP432 line 189</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4943?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4943</a></td>
        <td>MISRA 12.2 is incorrectly issued when one variable is used multiple times as an array index in the same expression</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4934?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4934</a></td>
        <td>Incorrect issue MISRA diagnostic 10.5: If the bitwise operators ~ and &lt;&lt; are applied</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4789?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4789</a></td>
        <td>Compiler incorrectly issues MISRA diagnostic 12.7 Bitwise operators shall not be applied to operands whose underlying type i</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4346?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4346</a></td>
        <td>MISRA 19.4 error fails to identify itself as MISRA diagnostic when problem is on the command line</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4304?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4304</a></td>
        <td>runtime failure on unaligned access (on some processor variants, not all)</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The following code results in an unaligned access failure in the ARM simulator when compiled with:



armcl -mv5e -me --float_support=vfpv2



#include &lt;map&gt;

#include &lt;stdio.h&gt;



int main(void)

{

        std::map&lt;int, char&gt;::size_type n=9;

        std::map&lt;int, char&gt; g;

        char s[] = "contrived";

        for (int i=0; i&lt;n; i++) {

            char k = s[i];

            std::pair&lt;const int, char&gt; p((int)k, k);

            g.insert(p);

        }



        int i00 = 0;

        std::map&lt;int, char&gt;::iterator it00 = g.begin();

        printf("start for loop\n");

        while (it00++ != g.end())

        {

           printf("iteration %d\n", i00++);

        }

        printf("out of for loop\n");

        return (1);

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4298?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4298</a></td>
        <td>Internal error when passing a temporary array of objects</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The following example code exhibits an internal compiler error caused by passing a temporary C array as an argument to a function taking an rvalue reference to an array:



struct S {

    int m;

    S(int i=1) : m(i) {}

    operator int() { return m; }

    int operator +(const S&amp; r) { return m+r.m; }

};



int f00(S (&amp;&amp;r)[3]) { return r[0] + r[1] + r[2]; }



int main(void) {

        int g;

        S a(97), b(2), c(1);

        g = f00({a, b, c});

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4297?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4297</a></td>
        <td>Cannot take the address of std::ctype&lt;char&gt;::table_size</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>This is a defect in the library. The table_size field is declared as having a constant value in the class definition, but there is no one definition for the field in the library.



Taking the address of this field will result in a link-time error.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4296?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4296</a></td>
        <td>Undefined symbol isblank with -g or -ooff</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The C99 function 'isblank' from ctype.h is provided as an inline definition when optimization is turned on, but there is no definition when optimization is turned off, leading to a link-time failure.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4290?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4290</a></td>
        <td>wstring runtime failure - likely bug in swprintf</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4281?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4281</a></td>
        <td>Unexpected type returned by bitset [] operator</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The operator[] definition for std::bitset returns a const reference to an internally defined class type, rather than a bool as required by C++14 section 20.6.2</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4276?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4276</a></td>
        <td>std::multimap::clear is not noexcept</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The library does not declare std::multimap::clear as noexcept, which is required by C++14 section 23.4.5.1 paragraph 2</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4275?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4275</a></td>
        <td>std::num_get does not parse floating-point strings correctly</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>



The C++ library locale helper, std::num_get, currently fails to correctly parser floating-point values in strings and streams. These calculations will always result in the default value of 0.0 for doubles, and 0.0f for floats.



Please use the C library equivalents, such as sprintf, to perform such operations.

</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4259?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4259</a></td>
        <td>noexcept(typeid(d)) runtime fail on polymorphic class type</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4258?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4258</a></td>
        <td>deeply nested lambda functions hang the codegen</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4250?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4250</a></td>
        <td>regex_constants::ECMAScript not expected to be 0</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>std::regex_constraints is a bitmask type, whose definition can be found in C++14 section 17.5.2.1.3. Paragraph 3 of this definition states that all values in the bitmask must be nonzero, so that zero can be used as a special 'empty bitmask' value.



The current implementation assigns std::regex_constraints::ECMAScript to 0, which goes against the definition.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4248?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4248</a></td>
        <td>armcl allows non-default arguments to be specified after default arguments</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The following code should emit a syntax error due to the specification of a second, non-defaulted argument after a defaulted argument. However, the compiler will abort with an internal error.



extern void foo(int, int);

void f() {

    auto l = [](int i=1, int j) { foo(i, j); };

    l();

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4247?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4247</a></td>
        <td>Internal error when assigning default arguments to a parameter pack</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The C++14 standard explicitly prohibits assigning default arguments to a

template parameter pack. However, the compile accepts such code silently, and may result in an internal error during compilation.



template &lt;class... Types&gt; void f(Types... args) {

    auto lm = [](Types... = args...) {};

    lm(10); // internal error here

}

int main() { f(1, 23); return 0; }</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4246?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4246</a></td>
        <td>armcl allows illegal attribute in friend declarations</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4245?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4245</a></td>
        <td>Multiple non-variables may be declared using auto or decltype(auto)</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>C++14 Section 7.1.6.4 paragraph 8 states that if multiple declarators are on the same line as an auto or decltype(auto) specifying, they must all be variable declarations.



However, our implementation does not enforce this requirement, allowing constructs of the following form:



auto f(void)-&gt;int, g(void)-&gt;char;</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4244?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4244</a></td>
        <td>armcl errors on legal constexpr constructor call</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4234?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4234</a></td>
        <td>No error generated for lambda-expression in default argument cannot capture any entity.</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4228?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4228</a></td>
        <td>armcl fails to flag an inconsistent use of alignas between a declaration and definition of an object</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4203?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4203</a></td>
        <td>Parser errors on empty enum declaration</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The following code causes an error.



enum : bool { };



While both gcc and clang mark this with a warning, our compiler marks it as an error, due to the declaration being functionally useless and most likely unintentional.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4158?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4158</a></td>
        <td>TI compiler does not emit clang error: constexpr function never produces a constant expression</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4157?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4157</a></td>
        <td>error with using constexpr for return from end() with empty std::initializer_list</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4132?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4132</a></td>
        <td>cannot find matching "==" operator definition</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The library does not provide an definition of std::operator== for arguments of type std::istream_iterator. That is, the following code is erroneously marked as ill-formed with a diagnostic:



#include &lt;iterator&gt;

#include &lt;string&gt;

using ISTREAM_ITER_C = std::istream_iterator&lt;char, char&gt;;



bool foo(const ISTREAM_ITER_C&amp; arg00 ,const ISTREAM_ITER_C&amp; arg01 ){

	return std::operator==  (arg00, arg01); // Syntax error

}



However, this is only an issue if called in exactly that way. Using it as an operator, rather than as a function call, works as expected:



arg00 == arg01 // Works</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4124?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4124</a></td>
        <td>Failure to defer access control checks</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4122?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4122</a></td>
        <td>decltype cannot be used as a destructor name</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4119?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4119</a></td>
        <td>user-supplied allocator function is not called</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4105?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4105</a></td>
        <td>cannot find definition of "&gt;=" operator</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4099?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4099</a></td>
        <td>Composing operations for valarray may fail to compile</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>Due to a potential implementation issue in the libc++ library, utilizing the valarray class and composing a result via multiple operations may fail.



For example:



const std::valarray&lt;float&gt; cl(6);

std::slice arg1(0,0,0);

std::slice slice(0,0,0);

cl[arg1][slice]; // Compilation error!</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4091?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4091</a></td>
        <td>Incomplete class type when using various members of &lt;iterator&gt;</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The following code sample results in an incomplete type error:



#include &lt;iterator&gt; 

int main(void)

{

        bool always_false = false;

        if (always_false) {

                std::istreambuf_iterator&lt;char&gt; cl;

                std::istreambuf_iterator&lt;char&gt; var1;

                const std::istreambuf_iterator&lt;char&gt; &amp; arg1 = var1;

                (void) cl.equal(arg1);

        }

        return 1;

}



The question is whether including &lt;iterator&gt; ought to include &lt;streambuf&gt;, which includes the definition for std::basic_streambuf, which is required by the definition of std::istreambuf_iterator.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4090?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4090</a></td>
        <td>Unimplemented core issue 475: std::uncaught_exception is not true when constructing the thrown object</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>In the code below, std::uncaught_exception should be true when constructing the A object that is constructed to be propagated to the catch block. The current implementation returns false.



#include &lt;exception&gt;

#include &lt;assert.h&gt;



struct A {

    int i;

    A() : i(0) {}

    A(const A&amp;) : i(std::uncaught_exception() ? 5 : 0) {}

    ~A() { }

};



int main()

{

    try {

        A a;

        assert(a.i == 0);

        throw a;

    } catch (A a) {

        assert(a.i == 5); // Fails

    }

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4084?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4084</a></td>
        <td>assembler errors with bogus .iendfunc asm directive when using --c_src_interlist</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4076?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4076</a></td>
        <td>Exception propagating out of noexcept function does not call std::terminate</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4072?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4072</a></td>
        <td>Unimplemented core issue 1769: Catching a thrown derived class by reference to base clas</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>Core 1769, involving a resolution which states that derived classes can be thrown and caught by catch clauses denoting an unambiguous base, has not been implemented.



#include &lt;assert.h&gt;



struct BaseClass {

    int i;

    BaseClass() : i(0) { }

    BaseClass(int ii) : i(ii) { }

    BaseClass(const BaseClass&amp; r) : i(r.i) { }

};



class DerivedClass : BaseClass {

    int ib;

  public:

    DerivedClass(const DerivedClass&amp; r) : BaseClass(r.ib), ib(r.ib) { }

    DerivedClass(const BaseClass&amp;) : BaseClass(999), ib(999)  { }

    DerivedClass(int ii);

};



DerivedClass thrown_base (1);

DerivedClass::DerivedClass(int ii) : BaseClass(ii), ib(ii) { }



int main() {

    try {

        throw thrown_base;

        return 999;

    }

    catch(const BaseClass &amp;k) {                       }

    catch(...)                              { assert(false); } // Assertion fails at runtime due to core issue 1769

    return 0;

}

</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4071?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4071</a></td>
        <td>&lt;regex&gt; never throws error_ctype</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>Due to an implementation detail, the &lt;regex&gt; header will never throw an exception corresponding to std::regex_constants::error_ctype. This can be exhibited from the below code sample:



#include &lt;regex&gt;

int main(void) {



  try {

    std::regex e("[[:not_a_class:]]", std::regex_constants::ECMAScript);

    std::regex_match("a", e);

  }

  catch(std::regex_error e){

    // e.code() will not be std::regex_constants::error_ctype

  }

  return 0;

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4069?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4069</a></td>
        <td>std::linear_congruential_engine doesn't support 8-bit results</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>Instantiations of std::linear_congruential_engine are only support for types between 64 and 16 bits. Therefore, on ARM and MSP430, the 'unsigned char' type is not supported.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4058?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4058</a></td>
        <td>std::function&lt;T&gt;::target_type() should return typeid(void) if target is empty</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4050?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4050</a></td>
        <td>shared_ptr::get_deleter() should return the original deleter class without copying</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4044?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4044</a></td>
        <td>libcxx istreambuf_iterator points to end of string instead of character past match</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The C++11 standard says that the "iterator is always left pointing one position beyond the last character successfully matched." In this case, that's after zero characters, so the iterator should point to the first character, just as the test expects. However, libcxx doesn't do this; it returns the pointer to the end of the string, which is indeed composed of characters that might match a (hex) float, but that's not the final word.



The libc++ code has advanced the iterator to "end," which it should not have done because the input sequence did not match. The test case expects the match to fail, leaving an iterator pointing to something other than "end," and it dereferences the iterator; because the iterator is actually "end", we get a NULL pointer dereference and hilarity ensues.



I claim this is a flaw in the the libc++ implementation.



cutdown test case:



#include &lt;locale&gt;

#include &lt;sstream&gt;

typedef std::char_traits&lt;char&gt; test1;

typedef std::istreambuf_iterator&lt;char, test1&gt; istr_it;

struct  mynum : public std::num_get&lt;char, istr_it&gt; 

{

   iter_type my_do_get(iter_type first, iter_type last, std::ios_base&amp; str, 

                       std::ios_base::iostate&amp; st, bool&amp; val) const

   { return (do_get(first, last, str, st, val)); }

};



int main()

{

   mynum my_num_get;

   std::ios_base::iostate st = std::ios_base::goodbit;

   std::istringstream istr("abcdef");

   istr_it first(istr.rdbuf()), last;



   st = std::ios_base::goodbit;

   double dv = 0;

   if(*(first = my_num_get.get(first, last, istr, st, dv)) == 'a')

      return 1;

}



</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4035?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4035</a></td>
        <td>Compiler allows constant subtraction between pointers to different objects</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The compiler allows the following code without error:



struct STR {

   constexpr STR(): arr1{1,2}, arr2{3,4} {};

   const char arr1[2];

   const char arr2[2];

};

const struct STR str;

constexpr char const *ptr1 =  str.arr1;

constexpr char const *ptr3 =  str.arr2;   



constexpr int diff2 = ptr3 - ptr1;



The definition of diff2 subtracts pointers to different objects, and should be disallowed.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4032?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4032</a></td>
        <td>wofstream &lt;&lt; operator unexpected termination</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4026?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4026</a></td>
        <td>Non-standard partial ordering of variadic template partial specialization</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4015?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4015</a></td>
        <td>Access of const static member through pointer is not a constant expression.</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The compiler emits an arguably spurious error on an access of a const static data member through a pointer when a constant expression is required. While gcc allows this silently, both the TI compiler and clang emit errors in stricter modes.



struct C { const static int m; };

const int C::m = 4;

C c, *cp = &amp;c;

int main(void)

{

	struct S02 { 

	    int x : cp-&gt;m; // error, not a constant expression

	};

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4002?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4002</a></td>
        <td>Undefined behavior on lambda capturing constexpr by reference</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4001?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4001</a></td>
        <td>Unimplemented core issue 588: Unqualified name lookup examines dependent base class</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>Similar to core issue 591 and CODEGEN-3963, this core issue resolves a lookup issue in a function template.



In the following source code, the struct 'A' will examine the scope of the base class D&lt;T&gt; to resolve the unqualified reference to B, when the core issue resolution states that D&lt;T&gt; should be skipped and the B found in the function template 'g' should be used instead.



struct B{ void f(int); };



template&lt;class T&gt; struct D: B { };



template&lt;class T&gt; void g() {

   struct B { void f(); };

   struct A : D&lt;T&gt; {

       B m;

   };

   A a;

   a.m.f(); // Presumably, we want ::g()::B::f(), not ::B::f(int)

}



int main () {

   g&lt;int&gt;();

   return 0;

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4000?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4000</a></td>
        <td>Core 1601: Overload resolution for enum with fixed type</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>Core issue 1601 states that the following code should call the overload of 'b' which takes a char argument, but the compiler chooses the int overload.



enum A : char { a };

int b(char) { return 1; }

int b(int) { return 999; }



int main()

{

    printf("%d\n", b(a));

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3999?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3999</a></td>
        <td>Unimplemented core issue 1374: Conversion sequence ranks qualification before reference binding</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The following code will print B, when both gcc and clang print A. This is due to a resolution to core issue 1374, which reorders the rankings of conversion sequences such that qualification difference are accounted for after reference binding differences, rather than before.



#include &lt;stdio.h&gt;

typedef int * T1;

typedef int *const  T2;

void foo(T1 &amp;) { printf("A\n"); } // (1)

void foo(T2 &amp;&amp;) { printf("B\n"); } // (2)

int main() {

  foo((int *)0); // Normally prefers (2), but now prefers

  return 0;         // (1) in GNU and Clang modes.

} </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3998?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3998</a></td>
        <td>Unimplemented core issue 1951: cv-qualified void and scalar types are not literal types</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>The type_trait helper std::remove_cv can ensure that qualifications have been stripped when using std::is_literal_type.</td>
        <td>The std::is_literal_type template function from the type_traits helper will erroneously have a value of 'false' for cv-qualified void and scalar types.

</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3993?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3993</a></td>
        <td>Constant initialiation may take place before dynamic initialization</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>In the following code, the rvalue reference 'br' will be initialized after the variable 'a', even though 'br' is constant initialized and 'a' is dynamically initialized. This ordering is required by C++14 Section 3.6.2 paragraph 2.



extern int a;

extern int f();



int a = f();



int&amp;&amp; br = 5;

int f() { return br; }

 

int main() {

  if (a != 5) return 1;

  return 0;

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3991?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3991</a></td>
        <td>We do not issue diagnostics if an allocation function throws a non bad_alloc exception</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3966?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3966</a></td>
        <td>slice_array assignment failures</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>None.</td>
        <td>slice_array assign fails runtime.



clang fails same as TI compiler. Both compile with no errors.



libc++ implementation copies a slice_array to another slice_array, stride by stride, and with both pointing to same original valarray. The original valarray changes values which in turn changes the values in the slice_array being assigned from.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3965?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3965</a></td>
        <td>Invalid conversion on static_cast from T1 to rvalue reference of T2</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The following code results in a syntax error, while it is accepted by both gcc and clang.



int main()

{

    char c = 1;

    const int &amp;&amp;r = static_cast&lt;const int&amp;&amp;&gt;(c);

    return r;

}



As a workaround, 'c' may be cast to int. However, doing so will not bind reference r to the variable c.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3964?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3964</a></td>
        <td>Unimplemented core issue 1467: Overloads and initializations with single-element initializer_list</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>This core issue has gone many iterations of fixes, and boils down to the issue of:



void foo(int x); // #1

void foo(std::initializer_list&lt;char&gt; x); // #2

foo({23}); // Calls #1 or #2?



The compiler currently calls #1, while gcc/clang both call #2.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3963?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3963</a></td>
        <td>Unimplemented core issue 591: Name lookup in dependent base class that is also the current instantiation</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The following code currently results in an error because the reference to B in the definition of A_&lt;T&gt;::C:: D is resolved to be C::B, which is void. Core issue 591 resolves this reference to A_&lt;T&gt;::B, which is int.



template&lt;class T&gt;

struct A_ {

	typedef int B;

	struct C {

		typedef void B;

		struct D;

	};

};

template&lt;class T&gt;

struct A_&lt;T&gt;::C::D : A_&lt;T&gt; {

	B b;

};</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3962?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3962</a></td>
        <td>Core Issue 1804 unimplemented: friend declaration does not apply to class template specializations</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The compiler does not yet implement the resolution to core issue 1804 involving template friend declarations applying to specializations of a class template. In the following code sample, a member of class C is inaccessible through a template friend declaration when the associated class template is a specialization.



class C_;



// Class template

template&lt;class T&gt; struct A_ {

  int f(const C_&amp;);

  struct D {

    int g() { return 8; }

  };

};



// Specialization

template&lt;&gt; struct A_&lt;int&gt; {

  int f(const C_&amp;);

  struct D {

    int g() { return 18; }

  };

};



class C_ {

  template&lt;class T&gt; friend int A_&lt;T&gt;::f(const C_&amp;); // friend declaration

  int member;

public:

  C_(int i) : member(i) { }

};



template&lt;class U&gt;

int A_&lt;U&gt;::f(const C_&amp; c)

  { return c.member; } // Not specialized, C::member is accessible



int A_&lt;int&gt;::f(const C_&amp; c)

  { return 10+c.member; } // Specialized, C::member is inaccessible</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3961?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3961</a></td>
        <td>Pack expansion in template parameter list fails</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3959?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3959</a></td>
        <td>std::reference_wrapper doesn't define argument_type for classes containing a typedef member named argument_type</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>C++14 section 20.9.3 paragraph 3 states that a reference_wrapper&lt;T&gt; shall define a typedef argument_type if T is a class type with a member type named argument_type.



The implementation does not support this, and only defines the member types described in paragraphs 2, 3, and 4 if T inherits or is convertible to unary_function or binary_function.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3954?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3954</a></td>
        <td>Problem with std::swap and &lt;tuple&gt;</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3953?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3953</a></td>
        <td>scoped_allocator_adaptor can't be explicitly instantiated with two arguments</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>Due to an implementation detail in the library, a specialization of scoped_allocator_adaptor with two template arguments (example below) will cause a compilation error.



#include &lt;memory&gt;

#include &lt;scoped_allocator&gt;

struct A00 :  std::allocator&lt;char&gt; {

  A00() {}

  template &lt;class P&gt; A00(const P&amp;) {}

};



template &lt;class T&gt; struct A01 {

  typedef T value_type;

  A01() {}

  template &lt;class P&gt; A01(const P&amp;) {}

  T* allocate(std::size_t n);

  void deallocate(T* p, std::size_t n);

};



template &lt;class T&gt; std::allocator&lt;T&gt; a02(void) {

  return std::allocator&lt;T&gt;();

}



int main()

{

   std::scoped_allocator_adaptor&lt;A00&gt; a00;

   const std::scoped_allocator_adaptor&lt;A00&gt;&amp; r00 = a00;

   if (!noexcept(std::scoped_allocator_adaptor&lt;A01&lt;int&gt;, A00&gt;(

                    a02&lt;int&gt;(), r00)))

      return 1;

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3951?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3951</a></td>
        <td>Spurious error on bypassing initialization of trivially constructible objects</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3948?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3948</a></td>
        <td>Spurious syntax error on alignas in alias declaration</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>In the following code, the 'alignas' attribute on the declaration of s1a is marked as a syntax error, even though the C++ 14 grammar explicitly allows it.



namespace a_ {

  struct alignas(0) s1 { int i; };

}

int main() {

  using s1a alignas(0) = a_::s1;

}



Furthermore, alignas will currently be ignored in relaxed mode or marked as an error in strict mode if used to specify the alignment of an enumeration type or a lambda object.

</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3947?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3947</a></td>
        <td>Spurious error on unevaluated use of undefined constexpr function</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3946?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3946</a></td>
        <td>Spurious error on global qualifier of struct template</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3944?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3944</a></td>
        <td>Raw string d-char-sequence isn't supported</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3941?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3941</a></td>
        <td>operator&lt;&lt;(std::basic_ostream&lt;K,T&gt;&amp;, const std::error_code&amp;) is not defined in system_error</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>#include &lt;ostream&gt; to get the definition of the operator</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3938?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3938</a></td>
        <td>std::rethrow_if_nested does not have standard signature</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The standard states that std::rethrow_if_nested have the signature:



template &lt;class E&gt; void rethrow_if_nested(const E&amp; e); // C++14 18.8.6 p9



The library implementation adds a second paramter to its definition of the function for the purpose of utilizing SFINAE.



This only affects uses of std::rethrow_if_nested if attempting to describe its signature as a type. As an example, the following attempt to capture the function pointer in a variable will fail to compile:



void (*p)(const int&amp;) = &amp;std::rethrow_if_nested&lt;int&gt;;</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3937?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3937</a></td>
        <td>nested_exception::rethrow_nested() not supported</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3916?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3916</a></td>
        <td>C++ header file cuchar is not provided in libc++</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The C++ header cuchar and its associated C header uchar.h are not available in our C++14 library due to lack of multibyte character string support.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00052872?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00052872</a></td>
        <td>#pragma LOCATION and palign do not work together</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>One workaround is to use specific placement in the linker command file.  In the C code, replace the #pragma LOCATION with a #pragma DATA_SECTION ...

    #pragma DATA_SECTION(device_fw_info_ptr, "for_device");

And in the linker command file, replace the whole .TI.bound line with this ...

    for_device &gt; 0x00018000, palign(8), fill = 0xffffffff

</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00052868?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00052868</a></td>
        <td>Automatic library build fails when an exact library name is used</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>Don't specify the name of the library.</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00052849?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00052849</a></td>
        <td>Compiler and assembler disagree on format for IT instruction</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00052780?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00052780</a></td>
        <td>The armhex command does not handle spaces in the name of the output binary</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-1458?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-1458</a></td>
        <td>Consider splitting up unified_locale.cpp to save code space</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-1445?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-1445</a></td>
        <td>Compiler inserts unnecessary register copy</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00051660?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00051660</a></td>
        <td>When the imaginary part of z is INFINITY, cprojf(z) is NOT equivalent to INFINITY + I * copysign(0.0, cimagf(z))</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00051484?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00051484</a></td>
        <td>Compiler does not respect partial overrides in C99 designated initializers</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>When using C99 designated initializers, initialize each desired subobject by itself and in the order declared.</td>
        <td>The compiler supports C99 designated initializers.  However, , if your initializer has more than one designator that refer, in whole or in part, to the same subobject, the compiler may initialize the subobjects in the wrong order, which can affect the value eventually used to initialize the subobject</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00051367?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00051367</a></td>
        <td>Disable diagnostic 1558 (--float_operations_allowed diagnostic) in standard header files</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00051165?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00051165</a></td>
        <td>Should accept "LDRD R8,[R1]" in Thumb-2 mode</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00051114?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00051114</a></td>
        <td>Missing half-precision float conversion functions</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00051113?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00051113</a></td>
        <td>Missing __aeabi_read_tp</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00051111?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00051111</a></td>
        <td>Missing AEABI_COMPATIBILITY_MODE link-time constants</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00051086?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00051086</a></td>
        <td>Assembler accepts but mistranslates BLLT in v7 thumb mode</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00051069?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00051069</a></td>
        <td>Should allow "ADD R0, R1, #0xfff" for v6m0</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>Use the syntax "ADDW R0, R1, #0xfff" instead.</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00051065?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00051065</a></td>
        <td>Should accept 2-operand SUB SP in Thumb1/UAL mode</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>Use ADD SP, SP, #&lt;imm&gt; instead
</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00050861?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00050861</a></td>
        <td>Should accept 2-operand add in ARM mode</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00050499?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00050499</a></td>
        <td>The .label assembler directive should not be accepted when assembling for ELF.</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00049911?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00049911</a></td>
        <td>__aeabi_dcmpun returns 1 for Inf and -Inf</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00049280?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00049280</a></td>
        <td>Ill advised enum scalar usage gets MISRA diagnostic, but similar usage of enum array does not</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00049278?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00049278</a></td>
        <td>Array that is correctly initialized erroneously gets a MISRA diagnostic about size not being specified</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00048267?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00048267</a></td>
        <td>Warning generated when using __curpc intrinsic on Thumb 2</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00047077?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00047077</a></td>
        <td>Double constant incorrectly converted to float changes result slightly</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>Cast such expressions to long or unsigned long instead.</td>
        <td>The compiler tries to optimize double precision constants as single precision constants when legal.  In this case, a double precision expression which happens not to round was converted to a float precision expression which does round, and this difference matters.  This bug can happen when a double precision expression involving a double precision constant (that is exactly representable in single precision) plus some other single precision value which might not exactly represent the decimal value in the source code is converted (implicitly or explicitly) to an integer type smaller than int.



Consider the expression 0.4f * 1000.0; 0.4 is not exactly representable in binary floating-point, so the compiler represents this with a value that is slightly less than 0.4.  The compiler assumed that because 1000 is exactly representable in single precision format, that it could safely change the expression to 0.4f * 1000.f, but 0.4f * 1000.0 &lt; 0.4f * 1000.0f, and that made a difference to this algorithm.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00046102?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00046102</a></td>
        <td>MISRA 12.8 and MISRA 10.5 false positives</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00046074?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00046074</a></td>
        <td>Cortex-M0 library lacks uread4, etc.</td>
        <td>Open</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>If using the TI compiler, the TI compiler doesn't call any of these functions, so no workaround should be necessary.
If using any other vendor's compiler and linking with the TI toolchain, link with the other vendor's toolchain.</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00040934?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00040934</a></td>
        <td>Structure is not initialized correctly when using -o2 or -o3 optimization</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>The initialization will have to be done at run-time, through a __sti initialization routine. You can see this routine when compiling without optimization. To workaround the compiler removing this initialization routine, initialize the object at the beginning of main:

Info2.mSize = ((unsigned)_end_isr_stack - (unsigned)_start_isr_stack);
</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00040523?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00040523</a></td>
        <td>The _ssat16 intrinsic allows literals in the range of 0-31, but the SSAT16 instruction only accepts values from 1-16</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00040522?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00040522</a></td>
        <td>_ssatl intrinsic allows 3rd argument to be 0 resulting in an assembler error.</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00039626?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00039626</a></td>
        <td>ARM assembler does not issue a warning for PC-relative loads when --embedded_constants=off</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00037008?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00037008</a></td>
        <td>Linker outputting wrong build attribute name for EABI TAG_VFP_arch on ARM targets</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00036874?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00036874</a></td>
        <td>Section relative ELF symbol values in partially linking object files should hold the section offset for the symbol</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00018691?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00018691</a></td>
        <td>Linker gives misleading warning when dot expressions used in SECTION directive for .stack section</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00008685?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00008685</a></td>
        <td>DWARF does not correctly represent variables stored in register pairs</td>
        <td>Planned</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>
Although 'var1' and 'var2' are shown to be in single registers, a 
debugger could determine that they are actually stored in register 
pairs by looking at the type of the variables:

   [00000113] DW_TAG_base_type
    DW_AT_name    long long
    DW_AT_encoding    0x5
    DW_AT_byte_size    0x8

The base type indicates that the size of the variables is 0x8 bytes.  
Since a single register can only store 0x4 bytes of information, it 
would take two registers to hold this values.

On TI architectures, values stored in multiple registers are always 
stored in consecutive registers.  Thus, the debugger would know that 
if the entire value could not fit in A4, the rest of the value must be 
in A5.  A5 would contain the upper 32 bits of the value.



</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00008543?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00008543</a></td>
        <td>Forward reference in .space generates an internal error</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>
none


</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00008248?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00008248</a></td>
        <td>Compilers on PC will not work without TMP set</td>
        <td>Accepted</td>
        <td>ARM_18.12.0.LTS</td>
        <td></td>
        <td>
Set the TMP environment variable, even if just set to . (current directory)


</td>
        <td> </td>
        </tr></tbody></table>
    <br>
    <b>Generated on Mon Oct  7 17:36:01 2019 </b>
    
    </body></html>